<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Choice Quiz</title>
  <link rel="stylesheet" href="Quiz2-Example.css">
</head>
<body>

<form id="quizForm">
  <h1>Multiple Choice Quiz</h1>

  <!-- Question 12 -->
  <div class="question">
    <p><b>1.</b> Is the following C++ code valid and safe?  Why or why not?<br>
&nbsp;&nbsp;<code>const char * HelloString() {</code><br>
&nbsp;&nbsp;<code>&nbsp;&nbsp;return &quot;Hello&quot;;</code><br>
&nbsp;&nbsp;<code>}</code></p>
    <div class="options"><label><input type="radio" name="q12" value="(A)">(A) Yes.  String literals are always copied when returned from a function, so it is safe to return one</label></div>
    <div class="options"><label><input type="radio" name="q12" value="(B)">(B) No. Any function that returns a string literal must be marked <code>const</code></label></div>
    <div class="options"><label><input type="radio" name="q12" value="(C)">(C) Yes.  String literals are valid for the lifetime of your program, so it is safe to return one</label></div>
    <div class="options"><label><input type="radio" name="q12" value="(D)">(D) No. The string <code>&quot;Hello&quot;</code> is local to this function and as such may result in corrupted memory</label></div>
  <div class="answer" data-question="q12"></div> <!-- Placeholder for answer --></div>

  <!-- Question 4 -->
  <div class="question">
    <p><b>2.</b> Which of the following is a valid reason that you should avoid <code>using namespace std;</code> in your code?</p>
    <div class="options"><label><input type="radio" name="q4" value="(A)">(A) The <code>using</code> command is deprecated.  You should always use <code>typedef</code> instead.</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(B)">(B) You will be polluting your current namespace with every identifier in the standard library</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(C)">(C) It will drastically limit the identifiers that you are allowed to use in your own code</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(D)">(D) It will drastically slow compilation times since substantial additional code will need to be compiled</label></div>
  <div class="answer" data-question="q4"></div> <!-- Placeholder for answer --></div>

  <!-- Question 36 -->
  <div class="question">
    <p><b>3.</b> What can the keyword <code>mutable</code> be used for in C++?</p>
    <div class="options"><label><input type="radio" name="q36" value="(A)">(A) To mark a parameter to a function that will definitely be modified in that function</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(B)">(B) To denote a member variable that is still allowed to change in a <code>const</code> member function</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(C)">(C) To indicate a class where the member variables in the class may vary from one instance to another</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(D)">(D) To specify that a class may be changed unexpectedly (possibly in a different thread).</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(E)">(E) To indicate that a class cannot be made <code>const</code></label></div>
    <div class="options"><label><input type="radio" name="q36" value="(F)">(F) To mark a member function as disallowed from being run on a const instance of a class</label></div>
  <div class="answer" data-question="q36"></div> <!-- Placeholder for answer --></div>

  <!-- Question 8 -->
  <div class="question">
    <p><b>4.</b> You should use an <code>std::array</code> from the C++ standard library (e.g., <code>std::array&lt;int, 10&gt; my_array</code> rather than a C-style array (e.g., <code>int my_array[10]</code>).  Which of the following is NOT a reason why?</p>
    <div class="options"><label><input type="radio" name="q8" value="(A)">(A) <code>std::array</code> tracks size information, while C-style arrays require you to track size yourself</label></div>
    <div class="options"><label><input type="radio" name="q8" value="(B)">(B) <code>std::array</code> provides helper functions, such as <code>.at</code> or <code>.back</code>; C-style arrays do not</label></div>
    <div class="options"><label><input type="radio" name="q8" value="(C)">(C) <code>std::array</code> can be used in range-based for loops; C-style arrays can not</label></div>
    <div class="options"><label><input type="radio" name="q8" value="(D)">(D) C-style arrays will often decay into pointers when you pass them into a function, losing some type information</label></div>
  <div class="answer" data-question="q8"></div> <!-- Placeholder for answer --></div>

  <!-- Question 16 -->
  <div class="question">
    <p><b>5.</b> What order are a class&apos; member variables initialized in?</p>
    <div class="options"><label><input type="radio" name="q16" value="(A)">(A) The same order as the associated parameters of the constructor</label></div>
    <div class="options"><label><input type="radio" name="q16" value="(B)">(B) The order in which they are placed in the initializer list of a constructor</label></div>
    <div class="options"><label><input type="radio" name="q16" value="(C)">(C) The order in which they are declared in the class</label></div>
    <div class="options"><label><input type="radio" name="q16" value="(D)">(D) This is undefined; they may be initialized in any order</label></div>
  <div class="answer" data-question="q16"></div> <!-- Placeholder for answer --></div>

  <!-- Question 32 -->
  <div class="question">
    <p><b>6.</b> How do you speed up your compilation using CPU architecture-specific optimizations?</p>
    <div class="options"><label><input type="radio" name="q32" value="(A)">(A) This is automatic when you use any of the -O optimization flags</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(B)">(B) You can specify the architecture with the <code>-march</code> flag, or <code>-march=native</code> to set it up automatically</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(C)">(C) You can use the <code>-Oarch</code> flag, though you must also include a separate flag for optimization level</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(D)">(D) You must use the -O3 optimization flag</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(E)">(E) Compilation is always specific to a given architecture and cannot be modified</label></div>
  <div class="answer" data-question="q32"></div> <!-- Placeholder for answer --></div>

  <!-- Question 1 -->
  <div class="question">
    <p><b>7.</b> What functionality is NOT provided by Doxygen?</p>
    <div class="options"><label><input type="radio" name="q1" value="(A)">(A) Checks to determine if your code is tested</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(B)">(B) Additional Markdown files that are formatted along with documentation</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(C)">(C) Autogeneration of indeces</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(D)">(D) Documentation of your code that resides in the code file itself</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(E)">(E) All of these are provided by Doxygen</label></div>
  <div class="answer" data-question="q1"></div> <!-- Placeholder for answer --></div>

  <!-- Question 28 -->
  <div class="question">
    <p><b>8.</b> If two variables are defined as <code>const int * x</code> and <code>int * const y</code>, what is the difference in their types?</p>
    <div class="options"><label><input type="radio" name="q28" value="(A)">(A) The variable <code>x</code> can point to both const and non-const integers, while <code>y</code> can only point to const integers</label></div>
    <div class="options"><label><input type="radio" name="q28" value="(B)">(B) Only the variable <code>x</code> can change the value stored at memory position where it points; only <code>y</code> can change which memory position it points to</label></div>
    <div class="options"><label><input type="radio" name="q28" value="(C)">(C) There is no difference; they are the same</label></div>
    <div class="options"><label><input type="radio" name="q28" value="(D)">(D) Only the variable <code>x</code> can change which memory position it points to; only <code>y</code> can change the value stored at memory position where it points</label></div>
    <div class="options"><label><input type="radio" name="q28" value="(E)">(E) The variable <code>x</code> cannot be set to <code>nullptr</code>, but <code>y</code> can</label></div>
  <div class="answer" data-question="q28"></div> <!-- Placeholder for answer --></div>

  <!-- Question 24 -->
  <div class="question">
    <p><b>9.</b> What is the advantage of using <code>std::make_unique</code> or <code>std::make_shared</code> over constructing your unique/shared pointers directly?</p>
    <div class="options"><label><input type="radio" name="q24" value="(A)">(A) It sets the output type to be a smart pointer so that deletion will be handled properly</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(B)">(B) It makes it easier to swap the underlying pointer</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(C)">(C) It&apos;s the only way to ensure that the pointer will have new memory allocated for it</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(D)">(D) It&apos;s just a convenience that simplifies the allocation process, passing arguments through to the constructor</label></div>
  <div class="answer" data-question="q24"></div> <!-- Placeholder for answer --></div>

  <!-- Question 20 -->
  <div class="question">
    <p><b>10.</b> Which of the following is a good reason to use <code>std::unique_ptr</code> instead of a raw pointer?</p>
    <div class="options"><label><input type="radio" name="q20" value="(A)">(A) We want multiple pointers to share ownership of the object</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(B)">(B) We want to clarify where in the code this pointer is owned</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(C)">(C) We never plan to dereference the pointer</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(D)">(D) We want to store the pointer in a <code>std::vector</code></label></div>
  <div class="answer" data-question="q20"></div> <!-- Placeholder for answer --></div>

  <hr><p>
  Click <b>Check Answers</b> to identify any errors and try again.  Click <b>Show Answers</b> if you also want to know which answer is the correct one.
  </p>
  <button type="button" id="checkAnswersBtn">Check Answers</button>
  <button type="button" id="showAnswersBtn">Show Answers</button>
</form>
<div id="results"></div>
<script src="Quiz2-Example.js"></script>
</body>
</html>
