<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Choice Quiz</title>
  <link rel="stylesheet" href="Quiz3-Example.css">
</head>
<body>

<form id="quizForm">
  <h1>Multiple Choice Quiz</h1>

  <!-- Question 13 -->
  <div class="question">
    <p><b>1.</b> Which of the following is NOT a difference between deterministic problems in your code and non-deterministic problems?</p>
    <div class="options"><label><input type="radio" name="q13" value="(A)">(A) In a debug build, deterministic problems can typically be replicated, but non-deterministic problems will often change symptoms.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(B)">(B) Non-deterministic problems are usually caused by invoking non-deterministic behavior, while deterministic problems are more typically issues with logic, syntax, or configuration.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(C)">(C) Asserts can help narrow down the location of deterministic problems, but are useless for non-deterministic problems.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(D)">(D) Deterministic problems can be replicated perfectly given identical inputs, but non-deterministic problems may change symptoms from one run to the next.</label></div>
  <div class="answer" data-question="q13"></div> <!-- Placeholder for answer --></div>

  <!-- Question 5 -->
  <div class="question">
    <p><b>2.</b> What happens if you use <code>const_cast</code> to cast away the constness of an object that was originally defined as <code>const</code> and then modify it?</p>
    <div class="options"><label><input type="radio" name="q5" value="(A)">(A) The original object will remain unchanged.</label></div>
    <div class="options"><label><input type="radio" name="q5" value="(B)">(B) The object will be modified without any issue.</label></div>
    <div class="options"><label><input type="radio" name="q5" value="(C)">(C) The program will have a segmentation fault.</label></div>
    <div class="options"><label><input type="radio" name="q5" value="(D)">(D) The behavior is undefined.</label></div>
    <div class="options"><label><input type="radio" name="q5" value="(E)">(E) An exception will be thrown.</label></div>
  <div class="answer" data-question="q5"></div> <!-- Placeholder for answer --></div>

  <!-- Question 33 -->
  <div class="question">
    <p><b>3.</b> Assume our API specifies the following integer exponentiation function declaration, and we have been asked to test it (this is <code>a</code> raised to the <code>b</code> power):<br>
<code></code><code></code><br>
int Exponentiate(int a, int b);<br>
<code></code><code></code><br>
Assuming the function declaration will not change, which of the following is not a useful test case?</p>
    <div class="options"><label><input type="radio" name="q33" value="(A)">(A) <code>REQUIRE(Exponentiate(-1, 3) == -1);</code></label></div>
    <div class="options"><label><input type="radio" name="q33" value="(B)">(B) <code>REQUIRE(Exponentiate(3, 0) == 1);</code></label></div>
    <div class="options"><label><input type="radio" name="q33" value="(C)">(C) <code>REQUIRE(Exponentiate(2, -1) == 0.5);</code></label></div>
    <div class="options"><label><input type="radio" name="q33" value="(D)">(D) <code>REQUIRE(Exponentiate(2, 3) == 8);</code></label></div>
    <div class="options"><label><input type="radio" name="q33" value="(E)">(E) <code>REQUIRE(Exponentiate(3, 2) == 9);</code></label></div>
  <div class="answer" data-question="q33"></div> <!-- Placeholder for answer --></div>

  <!-- Question 17 -->
  <div class="question">
    <p><b>4.</b> Which of the following is NOT a productive development practice for preventing bugs in your code?</p>
    <div class="options"><label><input type="radio" name="q17" value="(A)">(A) Add functionality in small sections of code at a time.</label></div>
    <div class="options"><label><input type="radio" name="q17" value="(B)">(B) Never refactor any code until you have a fully working system.</label></div>
    <div class="options"><label><input type="radio" name="q17" value="(C)">(C) Add asserts to test pre-conditions and post-conditions in new functions.</label></div>
    <div class="options"><label><input type="radio" name="q17" value="(D)">(D) Always verify that new functionality doesn&apos;t break previous tests.</label></div>
    <div class="options"><label><input type="radio" name="q17" value="(E)">(E) Each time you fix a bug, add a test to make sure a similar bug will be caught in the future.</label></div>
  <div class="answer" data-question="q17"></div> <!-- Placeholder for answer --></div>

  <!-- Question 23 -->
  <div class="question">
    <p><b>5.</b> Why should you use <code>std::make_unique</code> instead of <code>new</code> when constructing a <code>unique_ptr</code>?</p>
    <div class="options"><label><input type="radio" name="q23" value="(A)">(A) To delay object creation until first usage.</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(B)">(B) To ensure exception safety and efficiency.</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(C)">(C) To manually manage memory.</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(D)">(D) They are functionally identical and it doesn&apos;t matter.</label></div>
  <div class="answer" data-question="q23"></div> <!-- Placeholder for answer --></div>

  <!-- Question 35 -->
  <div class="question">
    <p><b>6.</b> Which of the following is _NOT_ an instance of undefined behavior in C++?</p>
    <div class="options"><label><input type="radio" name="q35" value="(A)">(A) Reading off the end of an <code>std::vector</code></label></div>
    <div class="options"><label><input type="radio" name="q35" value="(B)">(B) Signed integer overflow</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(C)">(C) Accessing un-initialized variables</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(D)">(D) Having multiple semicolons in a row after a statement</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(E)">(E) Integer divide by zero</label></div>
  <div class="answer" data-question="q35"></div> <!-- Placeholder for answer --></div>

  <!-- Question 9 -->
  <div class="question">
    <p><b>7.</b> Which of the following is a requirement for the source and destination types when using <code>std::bit_cast</code>?</p>
    <div class="options"><label><input type="radio" name="q9" value="(A)">(A) They must both be of pointer types.</label></div>
    <div class="options"><label><input type="radio" name="q9" value="(B)">(B) They must be derived from the same base class.</label></div>
    <div class="options"><label><input type="radio" name="q9" value="(C)">(C) They must both be arithmetic types.</label></div>
    <div class="options"><label><input type="radio" name="q9" value="(D)">(D) They must be the same size.</label></div>
    <div class="options"><label><input type="radio" name="q9" value="(E)">(E) There are no requirements; all conversions will work.</label></div>
  <div class="answer" data-question="q9"></div> <!-- Placeholder for answer --></div>

  <!-- Question 19 -->
  <div class="question">
    <p><b>8.</b> A <code>std::shared_ptr</code> can use the same operators as a raw pointer (e.g., <code>*</code> or <code>-&gt;</code>).  How is this accomplished?</p>
    <div class="options"><label><input type="radio" name="q19" value="(A)">(A) It requires <code>shared_ptr</code> to be built-in to the compiler to work, and cannot be implemented manually.</label></div>
    <div class="options"><label><input type="radio" name="q19" value="(B)">(B) The <code>shared_ptr</code> class must be derived from raw pointers to keep this functionality.</label></div>
    <div class="options"><label><input type="radio" name="q19" value="(C)">(C) The operators all work by default for any class that has a pointer as its first member variable.</label></div>
    <div class="options"><label><input type="radio" name="q19" value="(D)">(D) The relevant operators are overloaded in the <code>shared_ptr</code> class.</label></div>
  <div class="answer" data-question="q19"></div> <!-- Placeholder for answer --></div>

  <!-- Question 29 -->
  <div class="question">
    <p><b>9.</b> What does overloading <code>operator new</code> and <code>operator delete</code> allow you to do?</p>
    <div class="options"><label><input type="radio" name="q29" value="(A)">(A) They are always called before the system calls to <code>new</code> and <code>delete</code> and can&apos;t be used for anything other than debugging.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(B)">(B) Create brand new keywords for <code>new</code> and <code>delete</code> with a syntax of your choosing.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(C)">(C) Implement your own memory management.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(D)">(D) <code>new</code> and <code>delete</code> are built-in commands in C++ and cannot be overloaded.</label></div>
  <div class="answer" data-question="q29"></div> <!-- Placeholder for answer --></div>

  <!-- Question 1 -->
  <div class="question">
    <p><b>10.</b> What happens if you try to use <code>dynamic_cast</code> to convert a pointer, but the cast fails?</p>
    <div class="options"><label><input type="radio" name="q1" value="(A)">(A) An exception is thrown.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(B)">(B) A null pointer is returned.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(C)">(C) It always succeeds.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(D)">(D) The program aborts.</label></div>
  <div class="answer" data-question="q1"></div> <!-- Placeholder for answer --></div>

  <hr><p>
  Click <b>Check Answers</b> to identify any errors and try again.  Click <b>Show Answers</b> if you also want to know which answer is the correct one.
  </p>
  <button type="button" id="checkAnswersBtn">Check Answers</button>
  <button type="button" id="showAnswersBtn">Show Answers</button>
</form>
<div id="results"></div>
<script src="Quiz3-Example.js"></script>
</body>
</html>
